The code in the previous example does two things:
1. The program provides a simple menu interface.
2. When an action is chosen, it collects data and makes a call to a method of an Account manager object.
In this way, there is one large main program that does two different tasks.


The goal is to split the code into smaller logical units, each with a clearly defined role.


The menuing system will be the main code.
The rest of the code will deal with things the bank actually does.


The bank will be modeled as an object that manages the account objects, an object manager object.


Object Manager Object:
An object that maintains a list or dictionary of managed objects (typically of a single class) and calls methods of those objects.


To do this:
Take all the code related to the bank and put it in a Bank class.
The Bank class will be instantiated at the beginnning of the main program and manage a list or dictionary of Account objects.
In this way the Bank object will be the only code that communicates directly with the Account objects.


Composition (object composition):
A logical structure in which one object manages one or more objects.


Main Code
|
|             <------ composition
|
|
Bank object----------------------   
|                   |           |
|                   |           |
|                   |           |
|                   |           |
Acc. object   Acc. object   Acc. object


The Bank object is the only global variable.


The key advantage of this approach is that a much larger program has been broken down into smaller subprograms.
The main code and two classes (Bank and Account).


Programming is easier for each piece, because the scope of work is smaller and responsibilities clearer.


Having only a single global variable ensures that lower-level code will not accidentally affect the data at global level.