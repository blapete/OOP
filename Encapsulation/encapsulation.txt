Encapsulation means hiding internal details of state and behavior from any external code and having all code in one place.

- How encapsulation works with functions

- How encapsulation works with methods and objects

Different interpretations of encapsulation:

- Using direct access versus using getters and setters

- How Python allows to mark an instance variable as private, indicating that it should not be accessed by code external to a class

- The Python property decorator

- The concept of abstraction in the design of classes


-------


Functions are a example of encapsulation.

When you call a function, you generally don't care how the function works internally.

A well written function contains a series of steps that make up a larger single task, which does matter.

The name of the function should describe the action that its code embodies.


Example:

The built-in len() function from the Python Standard Library, used to find the number of characters in a string or elements in a list.

A string or list is passed in, and it returns the count.

When writing code that calls this function, it does not matter how len() does what it does.

It could be two lines or two thousand lines of code, one local variable or a hundred.

The important thing to know is what argument to pass in and how to use the result that's returned.


Example, a hand-made function:

def calculateAverage(numbersList):
    total = 0.0
    for number in numbersList:
        total = total + number
    nElements = len(numbersList)
    avergae = total / nElements
    return average

Once a function like this is tested and it works, no need to worry about the details of the implementation.

The important thing to know is what argument(s) to send into the function and what it returns.

In time if there is a much simpler or faster algorithm to calculate an average, rewrite the function in a new way.

As long as the interface (inputs and outputs) does not change, there is no need to change any calls to the function.

This type of modularization makes code more maintainable.


-------


Unlike variables used in regular functions, instance variables in objects persist across different method calls.


Client:
Any software that creates an object from a class and makes calls to the methods of that object.

The duality of inside versus outside an object or class:

When working inside a class (writing the code of the methods in a class), think about how the different methods of the class share the instance variables.

What the interface should look like; what methods to provide, what the parameters for each are, and what should be used as default values.

The design and implementation of the methods.

From the outside, as a client programmer, know the interface of the class.

What the class methods do, what arguments should be passed in, and what data is passed back from each method.


A class therefor provides encapsulation by:

- Hiding all details of implementation in its methods and instance variables.

- Providing all the functionality a client needs from an object through its interface (the methods defined in the class).


Objects own their data.

In object-oriented programming, it's said that the data inside an object is owned by the object.

Client code should only be concerned with the interface of a class and should not care about the implementation of its methods.


Example, data ownership in the Person class:

class Person():

    def __init__(self, name, salary):
        self.name = name
        self.salary = salary

The values of the instance variables self.name and self.salary are set whenever a new Person object is instantiated.

oPerson1 = Person('Joe Schmoe', 90000)
oPerson2 = Person('Jane Smith', 90000)

Each person object owns its own set of the two instance variables.